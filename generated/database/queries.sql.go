// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.14.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const addPlayerToMatch = `-- name: AddPlayerToMatch :one
INSERT INTO match_player (
  match_id, user_id, is_winner, score
) VALUES (
  $1, $2, $3, $4
)
RETURNING match_id, user_id, is_winner, score
`

type AddPlayerToMatchParams struct {
	MatchID  uuid.UUID
	UserID   uuid.UUID
	IsWinner bool
	Score    sql.NullInt32
}

func (q *Queries) AddPlayerToMatch(ctx context.Context, arg AddPlayerToMatchParams) (MatchPlayer, error) {
	row := q.db.QueryRowContext(ctx, addPlayerToMatch,
		arg.MatchID,
		arg.UserID,
		arg.IsWinner,
		arg.Score,
	)
	var i MatchPlayer
	err := row.Scan(
		&i.MatchID,
		&i.UserID,
		&i.IsWinner,
		&i.Score,
	)
	return i, err
}

const createGame = `-- name: CreateGame :one

INSERT INTO games (
  id, name
) VALUES (
  $1, $2
)
RETURNING id, name, rating_system
`

type CreateGameParams struct {
	ID   uuid.UUID
	Name string
}

// ########################################
// # GAMES
// ########################################
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.ID, arg.Name)
	var i Game
	err := row.Scan(&i.ID, &i.Name, &i.RatingSystem)
	return i, err
}

const createMatch = `-- name: CreateMatch :one

INSERT INTO matches (
  id, game_id, happened_at
) VALUES (
  $1, $2, $3
)
RETURNING id, game_id, happened_at
`

type CreateMatchParams struct {
	ID         uuid.UUID
	GameID     uuid.NullUUID
	HappenedAt time.Time
}

// ########################################
// # MATCHES
// ########################################
func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch, arg.ID, arg.GameID, arg.HappenedAt)
	var i Match
	err := row.Scan(&i.ID, &i.GameID, &i.HappenedAt)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id, name
) VALUES (
  $1, $2
)
RETURNING id, name
`

type CreateUserParams struct {
	ID   uuid.UUID
	Name string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.ID, arg.Name)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGame, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getEloMatchResult = `-- name: GetEloMatchResult :many
SELECT B.user_id, B.is_winner, B.score, C.rating, A.happened_at
FROM ((
  (SELECT id, happened_at FROM matches WHERE id = $1) as A
  INNER JOIN match_player as B ON A.id = B.match_id)
  INNER JOIN elo_rating as C ON B.user_id = C.user_id
)
`

type GetEloMatchResultRow struct {
	UserID     uuid.UUID
	IsWinner   bool
	Score      sql.NullInt32
	Rating     int32
	HappenedAt time.Time
}

func (q *Queries) GetEloMatchResult(ctx context.Context, id uuid.UUID) ([]GetEloMatchResultRow, error) {
	rows, err := q.db.QueryContext(ctx, getEloMatchResult, id)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEloMatchResultRow
	for rows.Next() {
		var i GetEloMatchResultRow
		if err := rows.Scan(
			&i.UserID,
			&i.IsWinner,
			&i.Score,
			&i.Rating,
			&i.HappenedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEloRating = `-- name: GetEloRating :one

SELECT rating FROM elo_rating
WHERE 
  user_id = $1 AND 
  game_id = $2
`

type GetEloRatingParams struct {
	Userid uuid.UUID
	Gameid uuid.UUID
}

// ########################################
// # ELO
// ########################################
func (q *Queries) GetEloRating(ctx context.Context, arg GetEloRatingParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getEloRating, arg.Userid, arg.Gameid)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const getGlickoMatchesAfter = `-- name: GetGlickoMatchesAfter :many
SELECT A.match_id as match_id, A.user_id, A.is_winner, A.score, B.current_rating, B.glicko_rating, B.glicko_deviation
FROM (
  SELECT match_id, user_id, is_winner, score 
  FROM match_player
  WHERE match_id IN 
  (
    SELECT matches.id
    FROM match_player INNER JOIN matches ON match_player.match_id = matches.id
    WHERE match_player.user_id = $1 AND matches.game_id = $2 AND matches.happened_at >= $3
  )
) AS A
INNER JOIN glicko_rating AS B ON A.user_id = B.user_id
GROUP BY A.match_id
`

type GetGlickoMatchesAfterParams struct {
	UserID     uuid.UUID
	GameID     uuid.NullUUID
	HappenedAt time.Time
}

type GetGlickoMatchesAfterRow struct {
	MatchID         uuid.UUID
	UserID          uuid.UUID
	IsWinner        bool
	Score           sql.NullInt32
	CurrentRating   sql.NullInt32
	GlickoRating    sql.NullInt32
	GlickoDeviation sql.NullFloat64
}

func (q *Queries) GetGlickoMatchesAfter(ctx context.Context, arg GetGlickoMatchesAfterParams) ([]GetGlickoMatchesAfterRow, error) {
	rows, err := q.db.QueryContext(ctx, getGlickoMatchesAfter, arg.UserID, arg.GameID, arg.HappenedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGlickoMatchesAfterRow
	for rows.Next() {
		var i GetGlickoMatchesAfterRow
		if err := rows.Scan(
			&i.MatchID,
			&i.UserID,
			&i.IsWinner,
			&i.Score,
			&i.CurrentRating,
			&i.GlickoRating,
			&i.GlickoDeviation,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getGlickoRating = `-- name: GetGlickoRating :one

SELECT user_id, game_id, current_rating, glicko_rating, glicko_deviation FROM glicko_rating
WHERE 
  user_id = $1 AND 
  game_id = $2
LIMIT 1
`

type GetGlickoRatingParams struct {
	Userid uuid.UUID
	Gameid uuid.UUID
}

// ########################################
// # GLICKO RATING
// ########################################
func (q *Queries) GetGlickoRating(ctx context.Context, arg GetGlickoRatingParams) (GlickoRating, error) {
	row := q.db.QueryRowContext(ctx, getGlickoRating, arg.Userid, arg.Gameid)
	var i GlickoRating
	err := row.Scan(
		&i.UserID,
		&i.GameID,
		&i.CurrentRating,
		&i.GlickoRating,
		&i.GlickoDeviation,
	)
	return i, err
}

const getMatches = `-- name: GetMatches :many
SELECT A.id 
FROM (
  (SELECT id, happened_at FROM matches WHERE game_id = $2) as A
  INNER JOIN 
  (SELECT match_id FROM match_player WHERE user_id = $1) AS B 
  ON A.id = B.match_id
)
`

type GetMatchesParams struct {
	UserID uuid.UUID
	GameID uuid.NullUUID
}

func (q *Queries) GetMatches(ctx context.Context, arg GetMatchesParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getMatches, arg.UserID, arg.GameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one

SELECT id, name FROM users
WHERE id = $1 LIMIT 1
`

// ########################################
// # Users
// ########################################
func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name FROM users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCurrentGlickoRating = `-- name: UpsertCurrentGlickoRating :exec
INSERT INTO glicko_rating (
  user_id, game_id, current_rating
) VALUES (
  $1, $2, $3
)
ON CONFLICT DO 
UPDATE SET current_rating = $3
`

type UpsertCurrentGlickoRatingParams struct {
	UserID        uuid.UUID
	GameID        uuid.UUID
	CurrentRating sql.NullInt32
}

func (q *Queries) UpsertCurrentGlickoRating(ctx context.Context, arg UpsertCurrentGlickoRatingParams) error {
	_, err := q.db.ExecContext(ctx, upsertCurrentGlickoRating, arg.UserID, arg.GameID, arg.CurrentRating)
	return err
}

const upsertEloRating = `-- name: UpsertEloRating :exec
INSERT INTO elo_rating (
  user_id, game_id, rating
) VALUES (
  $1, $2, $3
)
ON CONFLICT DO 
UPDATE SET rating = $3
`

type UpsertEloRatingParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
	Rating int32
}

func (q *Queries) UpsertEloRating(ctx context.Context, arg UpsertEloRatingParams) error {
	_, err := q.db.ExecContext(ctx, upsertEloRating, arg.UserID, arg.GameID, arg.Rating)
	return err
}

const upsertFullGlickoRating = `-- name: UpsertFullGlickoRating :exec
INSERT INTO glicko_rating (
  user_id, game_id, current_rating, glicko_rating, glicko_deviation
) VALUES (
  $1, $2, $3, $4, $5
)
ON CONFLICT DO 
UPDATE SET current_rating = $3, glicko_rating = $4, glicko_deviation = $5
`

type UpsertFullGlickoRatingParams struct {
	UserID          uuid.UUID
	GameID          uuid.UUID
	CurrentRating   sql.NullInt32
	GlickoRating    sql.NullInt32
	GlickoDeviation sql.NullFloat64
}

func (q *Queries) UpsertFullGlickoRating(ctx context.Context, arg UpsertFullGlickoRatingParams) error {
	_, err := q.db.ExecContext(ctx, upsertFullGlickoRating,
		arg.UserID,
		arg.GameID,
		arg.CurrentRating,
		arg.GlickoRating,
		arg.GlickoDeviation,
	)
	return err
}
