// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.15.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const addPlayerToMatch = `-- name: AddPlayerToMatch :one
INSERT INTO match_player (
  match_id, user_id
) VALUES (
  $1, $2
)
RETURNING match_id, user_id, score, rating_before, rating_change
`

type AddPlayerToMatchParams struct {
	MatchID uuid.UUID
	UserID  uuid.UUID
}

func (q *Queries) AddPlayerToMatch(ctx context.Context, arg AddPlayerToMatchParams) (MatchPlayer, error) {
	row := q.db.QueryRowContext(ctx, addPlayerToMatch, arg.MatchID, arg.UserID)
	var i MatchPlayer
	err := row.Scan(
		&i.MatchID,
		&i.UserID,
		&i.Score,
		&i.RatingBefore,
		&i.RatingChange,
	)
	return i, err
}

const applyRatingDiff = `-- name: ApplyRatingDiff :exec
UPDATE rating
SET rating = rating + $3
WHERE user_id = $1 AND game_id = $2
`

type ApplyRatingDiffParams struct {
	UserID     uuid.UUID
	GameID     uuid.UUID
	Ratingdiff int32
}

func (q *Queries) ApplyRatingDiff(ctx context.Context, arg ApplyRatingDiffParams) error {
	_, err := q.db.ExecContext(ctx, applyRatingDiff, arg.UserID, arg.GameID, arg.Ratingdiff)
	return err
}

const createGame = `-- name: CreateGame :one

INSERT INTO games (
    id, name, rating_system
) VALUES (
    gen_random_uuid(), $1, $2
)
RETURNING id, name, rating_system
`

type CreateGameParams struct {
	Name         string
	RatingSystem RatingSystemEnum
}

// ########################################
// # GAMES
// ########################################
func (q *Queries) CreateGame(ctx context.Context, arg CreateGameParams) (Game, error) {
	row := q.db.QueryRowContext(ctx, createGame, arg.Name, arg.RatingSystem)
	var i Game
	err := row.Scan(&i.ID, &i.Name, &i.RatingSystem)
	return i, err
}

const createMatch = `-- name: CreateMatch :one

INSERT INTO matches (
  id, game_id, happened_at
) VALUES (
  gen_random_uuid(), $1, $2
)
RETURNING id, game_id, finished, ratings_updated, happened_at
`

type CreateMatchParams struct {
	GameID     uuid.UUID
	HappenedAt time.Time
}

// ########################################
// # MATCHES
// ########################################
func (q *Queries) CreateMatch(ctx context.Context, arg CreateMatchParams) (Match, error) {
	row := q.db.QueryRowContext(ctx, createMatch, arg.GameID, arg.HappenedAt)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.Finished,
		&i.RatingsUpdated,
		&i.HappenedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  id, name
) VALUES (
  gen_random_uuid(), $1
)
RETURNING id, name
`

func (q *Queries) CreateUser(ctx context.Context, name string) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, name)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const deleteGame = `-- name: DeleteGame :exec
DELETE FROM games
WHERE id = $1
`

func (q *Queries) DeleteGame(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGame, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getGame = `-- name: GetGame :one
SELECT id, name, rating_system FROM games WHERE id = $1
`

func (q *Queries) GetGame(ctx context.Context, id uuid.UUID) (Game, error) {
	row := q.db.QueryRowContext(ctx, getGame, id)
	var i Game
	err := row.Scan(&i.ID, &i.Name, &i.RatingSystem)
	return i, err
}

const getMatchForUpdate = `-- name: GetMatchForUpdate :one
SELECT id, game_id, finished, ratings_updated, happened_at FROM matches WHERE id = $1 FOR UPDATE
`

func (q *Queries) GetMatchForUpdate(ctx context.Context, id uuid.UUID) (Match, error) {
	row := q.db.QueryRowContext(ctx, getMatchForUpdate, id)
	var i Match
	err := row.Scan(
		&i.ID,
		&i.GameID,
		&i.Finished,
		&i.RatingsUpdated,
		&i.HappenedAt,
	)
	return i, err
}

const getMatchPlayers = `-- name: GetMatchPlayers :many
SELECT match_id, user_id, score, rating_before, rating_change FROM match_player WHERE match_id = $1
`

func (q *Queries) GetMatchPlayers(ctx context.Context, matchID uuid.UUID) ([]MatchPlayer, error) {
	rows, err := q.db.QueryContext(ctx, getMatchPlayers, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchPlayer
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.UserID,
			&i.Score,
			&i.RatingBefore,
			&i.RatingChange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatchResult = `-- name: GetMatchResult :many
SELECT match_id, user_id, score, rating_before, rating_change FROM match_player WHERE match_id = $1
`

func (q *Queries) GetMatchResult(ctx context.Context, matchID uuid.UUID) ([]MatchPlayer, error) {
	rows, err := q.db.QueryContext(ctx, getMatchResult, matchID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MatchPlayer
	for rows.Next() {
		var i MatchPlayer
		if err := rows.Scan(
			&i.MatchID,
			&i.UserID,
			&i.Score,
			&i.RatingBefore,
			&i.RatingChange,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMatches = `-- name: GetMatches :many
SELECT A.id 
FROM (
  (SELECT id, happened_at FROM matches WHERE game_id = $2) as A
  INNER JOIN 
  (SELECT match_id FROM match_player WHERE user_id = $1) AS B 
  ON A.id = B.match_id
)
`

type GetMatchesParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
}

func (q *Queries) GetMatches(ctx context.Context, arg GetMatchesParams) ([]uuid.UUID, error) {
	rows, err := q.db.QueryContext(ctx, getMatches, arg.UserID, arg.GameID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []uuid.UUID
	for rows.Next() {
		var id uuid.UUID
		if err := rows.Scan(&id); err != nil {
			return nil, err
		}
		items = append(items, id)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRating = `-- name: GetRating :one

SELECT rating FROM rating
WHERE 
  user_id = $1 AND 
  game_id = $2
`

type GetRatingParams struct {
	Userid uuid.UUID
	Gameid uuid.UUID
}

// ########################################
// # ELO
// ########################################
func (q *Queries) GetRating(ctx context.Context, arg GetRatingParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRating, arg.Userid, arg.Gameid)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const getRatingForUpdate = `-- name: GetRatingForUpdate :one
SELECT rating FROM rating
WHERE 
  user_id = $1 AND 
  game_id = $2
FOR UPDATE
`

type GetRatingForUpdateParams struct {
	Userid uuid.UUID
	Gameid uuid.UUID
}

func (q *Queries) GetRatingForUpdate(ctx context.Context, arg GetRatingForUpdateParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, getRatingForUpdate, arg.Userid, arg.Gameid)
	var rating int32
	err := row.Scan(&rating)
	return rating, err
}

const getRatings = `-- name: GetRatings :many
SELECT rating FROM rating
WHERE 
  user_id = ANY($2::int[]) AND
  game_id = $1
`

type GetRatingsParams struct {
	GameID  uuid.UUID
	Column2 []int32
}

func (q *Queries) GetRatings(ctx context.Context, arg GetRatingsParams) ([]int32, error) {
	rows, err := q.db.QueryContext(ctx, getRatings, arg.GameID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []int32
	for rows.Next() {
		var rating int32
		if err := rows.Scan(&rating); err != nil {
			return nil, err
		}
		items = append(items, rating)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRatingsForUpdate = `-- name: GetRatingsForUpdate :many
SELECT user_id, rating FROM rating
WHERE 
  user_id = ANY($2::uuid[]) AND
  game_id = $1
FOR UPDATE
`

type GetRatingsForUpdateParams struct {
	GameID  uuid.UUID
	Column2 []uuid.UUID
}

type GetRatingsForUpdateRow struct {
	UserID uuid.UUID
	Rating int32
}

func (q *Queries) GetRatingsForUpdate(ctx context.Context, arg GetRatingsForUpdateParams) ([]GetRatingsForUpdateRow, error) {
	rows, err := q.db.QueryContext(ctx, getRatingsForUpdate, arg.GameID, pq.Array(arg.Column2))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetRatingsForUpdateRow
	for rows.Next() {
		var i GetRatingsForUpdateRow
		if err := rows.Scan(&i.UserID, &i.Rating); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one


SELECT id, name FROM users
WHERE id = $1 LIMIT 1
`

// noinspection SqlNoDataSourceInspectionForFile
// ########################################
// # Users
// ########################################
func (q *Queries) GetUser(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, id)
	var i User
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const listUsers = `-- name: ListUsers :many
SELECT id, name FROM users
`

func (q *Queries) ListUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const setMatchFinished = `-- name: SetMatchFinished :exec
UPDATE matches SET finished = true WHERE id = $1
`

func (q *Queries) SetMatchFinished(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setMatchFinished, id)
	return err
}

const setMatchRatingsUpdated = `-- name: SetMatchRatingsUpdated :exec
UPDATE matches SET ratings_updated = true WHERE id = $1
`

func (q *Queries) SetMatchRatingsUpdated(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, setMatchRatingsUpdated, id)
	return err
}

const updateMatchPlayer = `-- name: UpdateMatchPlayer :exec
UPDATE match_player
SET score = $3, rating_before = $4, rating_change = $5
WHERE match_id = $1 AND user_id = $2
`

type UpdateMatchPlayerParams struct {
	MatchID      uuid.UUID
	UserID       uuid.UUID
	Score        sql.NullInt32
	RatingBefore sql.NullInt32
	RatingChange sql.NullInt32
}

func (q *Queries) UpdateMatchPlayer(ctx context.Context, arg UpdateMatchPlayerParams) error {
	_, err := q.db.ExecContext(ctx, updateMatchPlayer,
		arg.MatchID,
		arg.UserID,
		arg.Score,
		arg.RatingBefore,
		arg.RatingChange,
	)
	return err
}

const upsertEloRating = `-- name: UpsertEloRating :exec
INSERT INTO rating (
  user_id, game_id, rating
) VALUES (
  $1, $2, $3
)
ON CONFLICT ON CONSTRAINT rating_pkey DO
UPDATE SET rating = $3
`

type UpsertEloRatingParams struct {
	UserID uuid.UUID
	GameID uuid.UUID
	Rating int32
}

func (q *Queries) UpsertEloRating(ctx context.Context, arg UpsertEloRatingParams) error {
	_, err := q.db.ExecContext(ctx, upsertEloRating, arg.UserID, arg.GameID, arg.Rating)
	return err
}
